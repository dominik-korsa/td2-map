use crate::parse::Checkpoint;
use glam::{Mat3, Vec2, Vec3};
use nalgebra::{Matrix2, SVD};

#[derive(Debug, Copy, Clone)]
pub(crate) struct RotatedCircle {
    original_radius: f32,
    start_rotation: Mat3,
    axes: EllipseAxes,
}

#[derive(Debug, Copy, Clone)]
pub(crate) struct EllipseAxes {
    pub(crate) major_axis: Vec2,
    pub(crate) minor_axis: Vec2,
}

// Generated by DeepSeek
fn get_projected_ellipse_axes(radius: f32, rotation: Mat3) -> EllipseAxes {
    let rotation_xz_components = Matrix2::new(
        rotation.x_axis.x, rotation.z_axis.x,
        rotation.x_axis.z, rotation.z_axis.z,
    );

    // Compute SVD (U contains left singular vectors, S singular values)
    let svd = SVD::new(rotation_xz_components, true, true);
    let u = svd.u.expect("U matrix should be computed");
    let s = svd.singular_values;

    let major_axis = u.column(0).into_owned() * s[0] * radius;
    let minor_axis = u.column(1).into_owned() * s[1] * radius;

    EllipseAxes {
        major_axis: Vec2::new(major_axis.x, major_axis.y),
        minor_axis: Vec2::new(minor_axis.x, minor_axis.y),
    }
}

impl RotatedCircle {
    /// Positive radius for a left curve and negative for a right curve
    pub(crate) fn new(original_radius: f32, rotation: Mat3) -> Self {
        Self {
            original_radius,
            start_rotation: rotation,
            axes: get_projected_ellipse_axes(original_radius, rotation),
        }
    }

    pub(crate) fn original_radius(&self) -> f32 {
        self.original_radius
    }

    /// Returns the matrix for the rotation transformation from moving by the angle along the curve.
    /// Does not include `self.rotation`.
    fn inner_rotation(&self, angle: f32) -> Mat3 {
        Mat3::from_rotation_y(-angle * self.original_radius.signum())
    }

    pub(crate) fn start_rotation(&self) -> Mat3 {
        self.start_rotation
    }

    pub(crate) fn move_by_angle(&self, start: Vec3, angle: f32) -> Checkpoint {
        let radius_vec = self.original_radius * Vec3::X;
        let inner_rotation = self.inner_rotation(angle);
        let start_to_end = -radius_vec + inner_rotation * radius_vec;
        Checkpoint {
            pos: start + self.start_rotation * start_to_end,
            rotation: self.start_rotation * inner_rotation,
        }
    }
}

fn transform(input: Vec2) -> Vec2  {
    Vec2::new(-input.y, -input.x)
}

/// Returns the axes of the projected ellipse
pub(crate) fn project_circle(circle: &RotatedCircle) -> EllipseAxes {
    EllipseAxes {
        major_axis: transform(circle.axes.major_axis),
        minor_axis: transform(circle.axes.minor_axis),
    }
}

pub(crate) fn project_pos(vec: &Vec3) -> Vec2 {
    transform(Vec2::new(vec.x, vec.z))
}